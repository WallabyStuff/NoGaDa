//
// This is a generated file, do not edit!
// Generated by R.swift, see https://github.com/mac-cain13/R.swift
//

import Foundation
import Rswift
import UIKit

/// This `R` struct is generated and contains references to static resources.
struct R: Rswift.Validatable {
  fileprivate static let applicationLocale = hostingBundle.preferredLocalizations.first.flatMap { Locale(identifier: $0) } ?? Locale.current
  fileprivate static let hostingBundle = Bundle(for: R.Class.self)

  /// Find first language and bundle for which the table exists
  fileprivate static func localeBundle(tableName: String, preferredLanguages: [String]) -> (Foundation.Locale, Foundation.Bundle)? {
    // Filter preferredLanguages to localizations, use first locale
    var languages = preferredLanguages
      .map { Locale(identifier: $0) }
      .prefix(1)
      .flatMap { locale -> [String] in
        if hostingBundle.localizations.contains(locale.identifier) {
          if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
            return [locale.identifier, language]
          } else {
            return [locale.identifier]
          }
        } else if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
          return [language]
        } else {
          return []
        }
      }

    // If there's no languages, use development language as backstop
    if languages.isEmpty {
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages = [developmentLocalization]
      }
    } else {
      // Insert Base as second item (between locale identifier and languageCode)
      languages.insert("Base", at: 1)

      // Add development language as backstop
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages.append(developmentLocalization)
      }
    }

    // Find first language for which table exists
    // Note: key might not exist in chosen language (in that case, key will be shown)
    for language in languages {
      if let lproj = hostingBundle.url(forResource: language, withExtension: "lproj"),
         let lbundle = Bundle(url: lproj)
      {
        let strings = lbundle.url(forResource: tableName, withExtension: "strings")
        let stringsdict = lbundle.url(forResource: tableName, withExtension: "stringsdict")

        if strings != nil || stringsdict != nil {
          return (Locale(identifier: language), lbundle)
        }
      }
    }

    // If table is available in main bundle, don't look for localized resources
    let strings = hostingBundle.url(forResource: tableName, withExtension: "strings", subdirectory: nil, localization: nil)
    let stringsdict = hostingBundle.url(forResource: tableName, withExtension: "stringsdict", subdirectory: nil, localization: nil)

    if strings != nil || stringsdict != nil {
      return (applicationLocale, hostingBundle)
    }

    // If table is not found for requested languages, key will be shown
    return nil
  }

  /// Load string from Info.plist file
  fileprivate static func infoPlistString(path: [String], key: String) -> String? {
    var dict = hostingBundle.infoDictionary
    for step in path {
      guard let obj = dict?[step] as? [String: Any] else { return nil }
      dict = obj
    }
    return dict?[key] as? String
  }

  static func validate() throws {
    try intern.validate()
  }

  #if os(iOS) || os(tvOS)
  /// This `R.storyboard` struct is generated, and contains static references to 6 storyboards.
  struct storyboard {
    /// Storyboard `Archive`.
    static let archive = _R.storyboard.archive()
    /// Storyboard `Folder`.
    static let folder = _R.storyboard.folder()
    /// Storyboard `LaunchScreen`.
    static let launchScreen = _R.storyboard.launchScreen()
    /// Storyboard `Main`.
    static let main = _R.storyboard.main()
    /// Storyboard `Search`.
    static let search = _R.storyboard.search()
    /// Storyboard `Setting`.
    static let setting = _R.storyboard.setting()

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "Archive", bundle: ...)`
    static func archive(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.archive)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "Folder", bundle: ...)`
    static func folder(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.folder)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "LaunchScreen", bundle: ...)`
    static func launchScreen(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.launchScreen)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "Main", bundle: ...)`
    static func main(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.main)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "Search", bundle: ...)`
    static func search(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.search)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "Setting", bundle: ...)`
    static func setting(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.setting)
    }
    #endif

    fileprivate init() {}
  }
  #endif

  /// This `R.color` struct is generated, and contains static references to 57 colors.
  struct color {
    /// Color `AccentColor`.
    static let accentColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "AccentColor")
    /// Color `AddFolderButtonBackgroundColor`.
    static let addFolderButtonBackgroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "AddFolderButtonBackgroundColor")
    /// Color `AddFolderButtonDisabledBackgroundColor`.
    static let addFolderButtonDisabledBackgroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "AddFolderButtonDisabledBackgroundColor")
    /// Color `AddFolderButtonForegroundColor`.
    static let addFolderButtonForegroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "AddFolderButtonForegroundColor")
    /// Color `AddFolderButtonReversedBackgroundColor`.
    static let addFolderButtonReversedBackgroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "AddFolderButtonReversedBackgroundColor")
    /// Color `AddFolderButtonReversedForegroundColor`.
    static let addFolderButtonReversedForegroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "AddFolderButtonReversedForegroundColor")
    /// Color `AppbarBackgroundColor`.
    static let appbarBackgroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "AppbarBackgroundColor")
    /// Color `AppbarExitButtonBackgroundColor`.
    static let appbarExitButtonBackgroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "AppbarExitButtonBackgroundColor")
    /// Color `AppbarTextColor`.
    static let appbarTextColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "AppbarTextColor")
    /// Color `AppbarTextfieldBackgroundColor`.
    static let appbarTextfieldBackgroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "AppbarTextfieldBackgroundColor")
    /// Color `AppbarTextfieldPlaceholderColor`.
    static let appbarTextfieldPlaceholderColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "AppbarTextfieldPlaceholderColor")
    /// Color `AppbarTextfieldTextColor`.
    static let appbarTextfieldTextColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "AppbarTextfieldTextColor")
    /// Color `ArchiveShortcutBackgroundColor`.
    static let archiveShortcutBackgroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "ArchiveShortcutBackgroundColor")
    /// Color `ArchiveShortcutPlaceholderColor`.
    static let archiveShortcutPlaceholderColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "ArchiveShortcutPlaceholderColor")
    /// Color `ArchiveShortcutSelectedBackgroundColor`.
    static let archiveShortcutSelectedBackgroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "ArchiveShortcutSelectedBackgroundColor")
    /// Color `BackgroundColor`.
    static let backgroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "BackgroundColor")
    /// Color `BrandPopUpButtonBorderColor`.
    static let brandPopUpButtonBorderColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "BrandPopUpButtonBorderColor")
    /// Color `ClearTextfieldButtonColor`.
    static let clearTextfieldButtonColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "ClearTextfieldButtonColor")
    /// Color `DisabledTextColor`.
    static let disabledTextColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "DisabledTextColor")
    /// Color `FloatingButtonBackgroundColor`.
    static let floatingButtonBackgroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "FloatingButtonBackgroundColor")
    /// Color `FloatingButtonForegroundColor`.
    static let floatingButtonForegroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "FloatingButtonForegroundColor")
    /// Color `FloatingPanelHandleColor`.
    static let floatingPanelHandleColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "FloatingPanelHandleColor")
    /// Color `IconResourceBoxBackgroundColor`.
    static let iconResourceBoxBackgroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "IconResourceBoxBackgroundColor")
    /// Color `NotificationViewBakcgroundColor`.
    static let notificationViewBakcgroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "NotificationViewBakcgroundColor")
    /// Color `NotificationViewCloseButtonColor`.
    static let notificationViewCloseButtonColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "NotificationViewCloseButtonColor")
    /// Color `PopOverBackgroundColor`.
    static let popOverBackgroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "PopOverBackgroundColor")
    /// Color `PopUpArchiveBackgroundColor`.
    static let popUpArchiveBackgroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "PopUpArchiveBackgroundColor")
    /// Color `PopUpArchiveSeparatorColor`.
    static let popUpArchiveSeparatorColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "PopUpArchiveSeparatorColor")
    /// Color `SegmentedControlAccentColor`.
    static let segmentedControlAccentColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "SegmentedControlAccentColor")
    /// Color `SegmentedControlBackgroundColor`.
    static let segmentedControlBackgroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "SegmentedControlBackgroundColor")
    /// Color `SegmentedControlDefaultTextColor`.
    static let segmentedControlDefaultTextColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "SegmentedControlDefaultTextColor")
    /// Color `SegmentedControlSelectedTextColor`.
    static let segmentedControlSelectedTextColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "SegmentedControlSelectedTextColor")
    /// Color `SeparatorColor`.
    static let separatorColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "SeparatorColor")
    /// Color `SettingGroupBackgroundColor`.
    static let settingGroupBackgroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "SettingGroupBackgroundColor")
    /// Color `SettingGroupHeaderTextColor`.
    static let settingGroupHeaderTextColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "SettingGroupHeaderTextColor")
    /// Color `SettingIconBoxBackgroundColor`.
    static let settingIconBoxBackgroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "SettingIconBoxBackgroundColor")
    /// Color `SettingIconBoxForegroundColor`.
    static let settingIconBoxForegroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "SettingIconBoxForegroundColor")
    /// Color `SettingItemSeparatorColor`.
    static let settingItemSeparatorColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "SettingItemSeparatorColor")
    /// Color `SongCellBackgroundColor`.
    static let songCellBackgroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "SongCellBackgroundColor")
    /// Color `SongCellForegroundColor`.
    static let songCellForegroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "SongCellForegroundColor")
    /// Color `SongCellNumberBoxBackgroundColor`.
    static let songCellNumberBoxBackgroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "SongCellNumberBoxBackgroundColor")
    /// Color `SongCellNumberBoxShadowColor`.
    static let songCellNumberBoxShadowColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "SongCellNumberBoxShadowColor")
    /// Color `SongCellNumberBoxStrokeColor`.
    static let songCellNumberBoxStrokeColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "SongCellNumberBoxStrokeColor")
    /// Color `SongCellNumberTextColor`.
    static let songCellNumberTextColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "SongCellNumberTextColor")
    /// Color `SongCellSelectedBackgroundColor`.
    static let songCellSelectedBackgroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "SongCellSelectedBackgroundColor")
    /// Color `SongCellStrokeColor`.
    static let songCellStrokeColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "SongCellStrokeColor")
    /// Color `SongThumbnailBackgroundColor`.
    static let songThumbnailBackgroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "SongThumbnailBackgroundColor")
    /// Color `SongThumbnailForegroundColor`.
    static let songThumbnailForegroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "SongThumbnailForegroundColor")
    /// Color `SplashBackgroundColor`.
    static let splashBackgroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "SplashBackgroundColor")
    /// Color `SubTextColor`.
    static let subTextColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "SubTextColor")
    /// Color `TextAccentColor`.
    static let textAccentColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "TextAccentColor")
    /// Color `TextColor`.
    static let textColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "TextColor")
    /// Color `TextFieldBackgroundColor`.
    static let textFieldBackgroundColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "TextFieldBackgroundColor")
    /// Color `TextFieldPlaceholderColor`.
    static let textFieldPlaceholderColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "TextFieldPlaceholderColor")
    /// Color `UpdatedSongSelectorBarIndicatorColor`.
    static let updatedSongSelectorBarIndicatorColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "UpdatedSongSelectorBarIndicatorColor")
    /// Color `UpdatedSongSelectorSelectedTextColor`.
    static let updatedSongSelectorSelectedTextColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "UpdatedSongSelectorSelectedTextColor")
    /// Color `UpdatedSongSelectorUnSelectedTextColor`.
    static let updatedSongSelectorUnSelectedTextColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "UpdatedSongSelectorUnSelectedTextColor")

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "AccentColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func accentColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.accentColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "AddFolderButtonBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func addFolderButtonBackgroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.addFolderButtonBackgroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "AddFolderButtonDisabledBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func addFolderButtonDisabledBackgroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.addFolderButtonDisabledBackgroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "AddFolderButtonForegroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func addFolderButtonForegroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.addFolderButtonForegroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "AddFolderButtonReversedBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func addFolderButtonReversedBackgroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.addFolderButtonReversedBackgroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "AddFolderButtonReversedForegroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func addFolderButtonReversedForegroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.addFolderButtonReversedForegroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "AppbarBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func appbarBackgroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.appbarBackgroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "AppbarExitButtonBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func appbarExitButtonBackgroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.appbarExitButtonBackgroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "AppbarTextColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func appbarTextColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.appbarTextColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "AppbarTextfieldBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func appbarTextfieldBackgroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.appbarTextfieldBackgroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "AppbarTextfieldPlaceholderColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func appbarTextfieldPlaceholderColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.appbarTextfieldPlaceholderColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "AppbarTextfieldTextColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func appbarTextfieldTextColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.appbarTextfieldTextColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "ArchiveShortcutBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func archiveShortcutBackgroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.archiveShortcutBackgroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "ArchiveShortcutPlaceholderColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func archiveShortcutPlaceholderColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.archiveShortcutPlaceholderColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "ArchiveShortcutSelectedBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func archiveShortcutSelectedBackgroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.archiveShortcutSelectedBackgroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "BackgroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func backgroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.backgroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "BrandPopUpButtonBorderColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func brandPopUpButtonBorderColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.brandPopUpButtonBorderColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "ClearTextfieldButtonColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func clearTextfieldButtonColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.clearTextfieldButtonColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "DisabledTextColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func disabledTextColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.disabledTextColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "FloatingButtonBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func floatingButtonBackgroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.floatingButtonBackgroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "FloatingButtonForegroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func floatingButtonForegroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.floatingButtonForegroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "FloatingPanelHandleColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func floatingPanelHandleColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.floatingPanelHandleColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "IconResourceBoxBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func iconResourceBoxBackgroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.iconResourceBoxBackgroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "NotificationViewBakcgroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func notificationViewBakcgroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.notificationViewBakcgroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "NotificationViewCloseButtonColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func notificationViewCloseButtonColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.notificationViewCloseButtonColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "PopOverBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func popOverBackgroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.popOverBackgroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "PopUpArchiveBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func popUpArchiveBackgroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.popUpArchiveBackgroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "PopUpArchiveSeparatorColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func popUpArchiveSeparatorColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.popUpArchiveSeparatorColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "SegmentedControlAccentColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func segmentedControlAccentColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.segmentedControlAccentColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "SegmentedControlBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func segmentedControlBackgroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.segmentedControlBackgroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "SegmentedControlDefaultTextColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func segmentedControlDefaultTextColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.segmentedControlDefaultTextColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "SegmentedControlSelectedTextColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func segmentedControlSelectedTextColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.segmentedControlSelectedTextColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "SeparatorColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func separatorColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.separatorColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "SettingGroupBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func settingGroupBackgroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.settingGroupBackgroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "SettingGroupHeaderTextColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func settingGroupHeaderTextColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.settingGroupHeaderTextColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "SettingIconBoxBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func settingIconBoxBackgroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.settingIconBoxBackgroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "SettingIconBoxForegroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func settingIconBoxForegroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.settingIconBoxForegroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "SettingItemSeparatorColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func settingItemSeparatorColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.settingItemSeparatorColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "SongCellBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func songCellBackgroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.songCellBackgroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "SongCellForegroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func songCellForegroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.songCellForegroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "SongCellNumberBoxBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func songCellNumberBoxBackgroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.songCellNumberBoxBackgroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "SongCellNumberBoxShadowColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func songCellNumberBoxShadowColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.songCellNumberBoxShadowColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "SongCellNumberBoxStrokeColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func songCellNumberBoxStrokeColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.songCellNumberBoxStrokeColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "SongCellNumberTextColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func songCellNumberTextColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.songCellNumberTextColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "SongCellSelectedBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func songCellSelectedBackgroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.songCellSelectedBackgroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "SongCellStrokeColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func songCellStrokeColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.songCellStrokeColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "SongThumbnailBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func songThumbnailBackgroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.songThumbnailBackgroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "SongThumbnailForegroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func songThumbnailForegroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.songThumbnailForegroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "SplashBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func splashBackgroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.splashBackgroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "SubTextColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func subTextColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.subTextColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "TextAccentColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func textAccentColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.textAccentColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "TextColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func textColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.textColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "TextFieldBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func textFieldBackgroundColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.textFieldBackgroundColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "TextFieldPlaceholderColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func textFieldPlaceholderColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.textFieldPlaceholderColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "UpdatedSongSelectorBarIndicatorColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func updatedSongSelectorBarIndicatorColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.updatedSongSelectorBarIndicatorColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "UpdatedSongSelectorSelectedTextColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func updatedSongSelectorSelectedTextColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.updatedSongSelectorSelectedTextColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "UpdatedSongSelectorUnSelectedTextColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func updatedSongSelectorUnSelectedTextColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.updatedSongSelectorUnSelectedTextColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "AccentColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func accentColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.accentColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "AddFolderButtonBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func addFolderButtonBackgroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.addFolderButtonBackgroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "AddFolderButtonDisabledBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func addFolderButtonDisabledBackgroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.addFolderButtonDisabledBackgroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "AddFolderButtonForegroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func addFolderButtonForegroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.addFolderButtonForegroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "AddFolderButtonReversedBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func addFolderButtonReversedBackgroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.addFolderButtonReversedBackgroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "AddFolderButtonReversedForegroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func addFolderButtonReversedForegroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.addFolderButtonReversedForegroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "AppbarBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func appbarBackgroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.appbarBackgroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "AppbarExitButtonBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func appbarExitButtonBackgroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.appbarExitButtonBackgroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "AppbarTextColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func appbarTextColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.appbarTextColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "AppbarTextfieldBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func appbarTextfieldBackgroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.appbarTextfieldBackgroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "AppbarTextfieldPlaceholderColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func appbarTextfieldPlaceholderColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.appbarTextfieldPlaceholderColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "AppbarTextfieldTextColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func appbarTextfieldTextColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.appbarTextfieldTextColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "ArchiveShortcutBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func archiveShortcutBackgroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.archiveShortcutBackgroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "ArchiveShortcutPlaceholderColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func archiveShortcutPlaceholderColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.archiveShortcutPlaceholderColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "ArchiveShortcutSelectedBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func archiveShortcutSelectedBackgroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.archiveShortcutSelectedBackgroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "BackgroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func backgroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.backgroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "BrandPopUpButtonBorderColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func brandPopUpButtonBorderColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.brandPopUpButtonBorderColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "ClearTextfieldButtonColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func clearTextfieldButtonColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.clearTextfieldButtonColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "DisabledTextColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func disabledTextColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.disabledTextColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "FloatingButtonBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func floatingButtonBackgroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.floatingButtonBackgroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "FloatingButtonForegroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func floatingButtonForegroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.floatingButtonForegroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "FloatingPanelHandleColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func floatingPanelHandleColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.floatingPanelHandleColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "IconResourceBoxBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func iconResourceBoxBackgroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.iconResourceBoxBackgroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "NotificationViewBakcgroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func notificationViewBakcgroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.notificationViewBakcgroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "NotificationViewCloseButtonColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func notificationViewCloseButtonColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.notificationViewCloseButtonColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "PopOverBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func popOverBackgroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.popOverBackgroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "PopUpArchiveBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func popUpArchiveBackgroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.popUpArchiveBackgroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "PopUpArchiveSeparatorColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func popUpArchiveSeparatorColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.popUpArchiveSeparatorColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "SegmentedControlAccentColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func segmentedControlAccentColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.segmentedControlAccentColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "SegmentedControlBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func segmentedControlBackgroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.segmentedControlBackgroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "SegmentedControlDefaultTextColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func segmentedControlDefaultTextColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.segmentedControlDefaultTextColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "SegmentedControlSelectedTextColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func segmentedControlSelectedTextColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.segmentedControlSelectedTextColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "SeparatorColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func separatorColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.separatorColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "SettingGroupBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func settingGroupBackgroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.settingGroupBackgroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "SettingGroupHeaderTextColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func settingGroupHeaderTextColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.settingGroupHeaderTextColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "SettingIconBoxBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func settingIconBoxBackgroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.settingIconBoxBackgroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "SettingIconBoxForegroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func settingIconBoxForegroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.settingIconBoxForegroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "SettingItemSeparatorColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func settingItemSeparatorColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.settingItemSeparatorColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "SongCellBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func songCellBackgroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.songCellBackgroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "SongCellForegroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func songCellForegroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.songCellForegroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "SongCellNumberBoxBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func songCellNumberBoxBackgroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.songCellNumberBoxBackgroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "SongCellNumberBoxShadowColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func songCellNumberBoxShadowColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.songCellNumberBoxShadowColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "SongCellNumberBoxStrokeColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func songCellNumberBoxStrokeColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.songCellNumberBoxStrokeColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "SongCellNumberTextColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func songCellNumberTextColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.songCellNumberTextColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "SongCellSelectedBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func songCellSelectedBackgroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.songCellSelectedBackgroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "SongCellStrokeColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func songCellStrokeColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.songCellStrokeColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "SongThumbnailBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func songThumbnailBackgroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.songThumbnailBackgroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "SongThumbnailForegroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func songThumbnailForegroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.songThumbnailForegroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "SplashBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func splashBackgroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.splashBackgroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "SubTextColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func subTextColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.subTextColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "TextAccentColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func textAccentColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.textAccentColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "TextColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func textColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.textColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "TextFieldBackgroundColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func textFieldBackgroundColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.textFieldBackgroundColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "TextFieldPlaceholderColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func textFieldPlaceholderColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.textFieldPlaceholderColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "UpdatedSongSelectorBarIndicatorColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func updatedSongSelectorBarIndicatorColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.updatedSongSelectorBarIndicatorColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "UpdatedSongSelectorSelectedTextColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func updatedSongSelectorSelectedTextColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.updatedSongSelectorSelectedTextColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "UpdatedSongSelectorUnSelectedTextColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func updatedSongSelectorUnSelectedTextColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.updatedSongSelectorUnSelectedTextColor.name)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.image` struct is generated, and contains static references to 11 images.
  struct image {
    /// Image `ArchiveShortcutBackgroundImage`.
    static let archiveShortcutBackgroundImage = Rswift.ImageResource(bundle: R.hostingBundle, name: "ArchiveShortcutBackgroundImage")
    /// Image `SplashImage`.
    static let splashImage = Rswift.ImageResource(bundle: R.hostingBundle, name: "SplashImage")
    /// Image `back-arrow`.
    static let backArrow = Rswift.ImageResource(bundle: R.hostingBundle, name: "back-arrow")
    /// Image `folder-filled`.
    static let folderFilled = Rswift.ImageResource(bundle: R.hostingBundle, name: "folder-filled")
    /// Image `folder`.
    static let folder = Rswift.ImageResource(bundle: R.hostingBundle, name: "folder")
    /// Image `information.fill`.
    static let informationFill = Rswift.ImageResource(bundle: R.hostingBundle, name: "information.fill")
    /// Image `music-note`.
    static let musicNote = Rswift.ImageResource(bundle: R.hostingBundle, name: "music-note")
    /// Image `plus`.
    static let plus = Rswift.ImageResource(bundle: R.hostingBundle, name: "plus")
    /// Image `setting`.
    static let setting = Rswift.ImageResource(bundle: R.hostingBundle, name: "setting")
    /// Image `sort-line`.
    static let sortLine = Rswift.ImageResource(bundle: R.hostingBundle, name: "sort-line")
    /// Image `trash-bin`.
    static let trashBin = Rswift.ImageResource(bundle: R.hostingBundle, name: "trash-bin")

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "ArchiveShortcutBackgroundImage", bundle: ..., traitCollection: ...)`
    static func archiveShortcutBackgroundImage(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.archiveShortcutBackgroundImage, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "SplashImage", bundle: ..., traitCollection: ...)`
    static func splashImage(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.splashImage, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "back-arrow", bundle: ..., traitCollection: ...)`
    static func backArrow(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.backArrow, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "folder", bundle: ..., traitCollection: ...)`
    static func folder(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.folder, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "folder-filled", bundle: ..., traitCollection: ...)`
    static func folderFilled(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.folderFilled, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "information.fill", bundle: ..., traitCollection: ...)`
    static func informationFill(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.informationFill, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "music-note", bundle: ..., traitCollection: ...)`
    static func musicNote(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.musicNote, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "plus", bundle: ..., traitCollection: ...)`
    static func plus(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.plus, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "setting", bundle: ..., traitCollection: ...)`
    static func setting(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.setting, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "sort-line", bundle: ..., traitCollection: ...)`
    static func sortLine(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.sortLine, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "trash-bin", bundle: ..., traitCollection: ...)`
    static func trashBin(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.trashBin, compatibleWith: traitCollection)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.info` struct is generated, and contains static references to 1 properties.
  struct info {
    struct uiApplicationSceneManifest {
      static let _key = "UIApplicationSceneManifest"
      static let uiApplicationSupportsMultipleScenes = false

      struct uiSceneConfigurations {
        static let _key = "UISceneConfigurations"

        struct uiWindowSceneSessionRoleApplication {
          struct defaultConfiguration {
            static let _key = "Default Configuration"
            static let uiSceneConfigurationName = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneConfigurationName") ?? "Default Configuration"
            static let uiSceneDelegateClassName = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneDelegateClassName") ?? "$(PRODUCT_MODULE_NAME).SceneDelegate"

            fileprivate init() {}
          }

          fileprivate init() {}
        }

        fileprivate init() {}
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  /// This `R.nib` struct is generated, and contains static references to 10 nibs.
  struct nib {
    /// Nib `FolderTableViewCell`.
    static let folderTableViewCell = _R.nib._FolderTableViewCell()
    /// Nib `IconResourceCollectionViewCell`.
    static let iconResourceCollectionViewCell = _R.nib._IconResourceCollectionViewCell()
    /// Nib `KaraokeBrandPickerTableViewCell`.
    static let karaokeBrandPickerTableViewCell = _R.nib._KaraokeBrandPickerTableViewCell()
    /// Nib `PopUpArchiveFolderTableViewCell`.
    static let popUpArchiveFolderTableViewCell = _R.nib._PopUpArchiveFolderTableViewCell()
    /// Nib `PopUpSongOptionTableViewCell`.
    static let popUpSongOptionTableViewCell = _R.nib._PopUpSongOptionTableViewCell()
    /// Nib `SearchFilterTableViewCell`.
    static let searchFilterTableViewCell = _R.nib._SearchFilterTableViewCell()
    /// Nib `SearchHistoryTableViewCell`.
    static let searchHistoryTableViewCell = _R.nib._SearchHistoryTableViewCell()
    /// Nib `SettingEtcTableViewCell`.
    static let settingEtcTableViewCell = _R.nib._SettingEtcTableViewCell()
    /// Nib `SongTableViewCell`.
    static let songTableViewCell = _R.nib._SongTableViewCell()
    /// Nib `UpdatedSongTableViewCell`.
    static let updatedSongTableViewCell = _R.nib._UpdatedSongTableViewCell()

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "FolderTableViewCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.folderTableViewCell) instead")
    static func folderTableViewCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.folderTableViewCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "IconResourceCollectionViewCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.iconResourceCollectionViewCell) instead")
    static func iconResourceCollectionViewCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.iconResourceCollectionViewCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "KaraokeBrandPickerTableViewCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.karaokeBrandPickerTableViewCell) instead")
    static func karaokeBrandPickerTableViewCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.karaokeBrandPickerTableViewCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "PopUpArchiveFolderTableViewCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.popUpArchiveFolderTableViewCell) instead")
    static func popUpArchiveFolderTableViewCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.popUpArchiveFolderTableViewCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "PopUpSongOptionTableViewCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.popUpSongOptionTableViewCell) instead")
    static func popUpSongOptionTableViewCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.popUpSongOptionTableViewCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "SearchFilterTableViewCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.searchFilterTableViewCell) instead")
    static func searchFilterTableViewCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.searchFilterTableViewCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "SearchHistoryTableViewCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.searchHistoryTableViewCell) instead")
    static func searchHistoryTableViewCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.searchHistoryTableViewCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "SettingEtcTableViewCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.settingEtcTableViewCell) instead")
    static func settingEtcTableViewCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.settingEtcTableViewCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "SongTableViewCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.songTableViewCell) instead")
    static func songTableViewCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.songTableViewCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "UpdatedSongTableViewCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.updatedSongTableViewCell) instead")
    static func updatedSongTableViewCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.updatedSongTableViewCell)
    }
    #endif

    static func folderTableViewCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> FolderTableViewCell? {
      return R.nib.folderTableViewCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? FolderTableViewCell
    }

    static func iconResourceCollectionViewCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> IconResourceCollectionViewCell? {
      return R.nib.iconResourceCollectionViewCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? IconResourceCollectionViewCell
    }

    static func karaokeBrandPickerTableViewCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> KaraokeBrandPickerTableViewCell? {
      return R.nib.karaokeBrandPickerTableViewCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? KaraokeBrandPickerTableViewCell
    }

    static func popUpArchiveFolderTableViewCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> PopUpArchiveFolderTableViewCell? {
      return R.nib.popUpArchiveFolderTableViewCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? PopUpArchiveFolderTableViewCell
    }

    static func popUpSongOptionTableViewCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> PopUpSongOptionTableViewCell? {
      return R.nib.popUpSongOptionTableViewCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? PopUpSongOptionTableViewCell
    }

    static func searchFilterTableViewCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> SearchFilterTableViewCell? {
      return R.nib.searchFilterTableViewCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? SearchFilterTableViewCell
    }

    static func searchHistoryTableViewCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> SearchHistoryTableViewCell? {
      return R.nib.searchHistoryTableViewCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? SearchHistoryTableViewCell
    }

    static func settingEtcTableViewCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> SettingEtcTableViewCell? {
      return R.nib.settingEtcTableViewCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? SettingEtcTableViewCell
    }

    static func songTableViewCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> SongTableViewCell? {
      return R.nib.songTableViewCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? SongTableViewCell
    }

    static func updatedSongTableViewCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UpdatedSongTableViewCell? {
      return R.nib.updatedSongTableViewCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UpdatedSongTableViewCell
    }

    fileprivate init() {}
  }

  /// This `R.reuseIdentifier` struct is generated, and contains static references to 10 reuse identifiers.
  struct reuseIdentifier {
    /// Reuse identifier `SearchResultTableViewCell`.
    static let searchResultTableViewCell: Rswift.ReuseIdentifier<SongTableViewCell> = Rswift.ReuseIdentifier(identifier: "SearchResultTableViewCell")
    /// Reuse identifier `folderTableViewCell`.
    static let folderTableViewCell: Rswift.ReuseIdentifier<FolderTableViewCell> = Rswift.ReuseIdentifier(identifier: "folderTableViewCell")
    /// Reuse identifier `iconResourceCollectionCell`.
    static let iconResourceCollectionCell: Rswift.ReuseIdentifier<IconResourceCollectionViewCell> = Rswift.ReuseIdentifier(identifier: "iconResourceCollectionCell")
    /// Reuse identifier `karaokeBrandTableCell`.
    static let karaokeBrandTableCell: Rswift.ReuseIdentifier<KaraokeBrandPickerTableViewCell> = Rswift.ReuseIdentifier(identifier: "karaokeBrandTableCell")
    /// Reuse identifier `popUpArchiveTableCell`.
    static let popUpArchiveTableCell: Rswift.ReuseIdentifier<PopUpArchiveFolderTableViewCell> = Rswift.ReuseIdentifier(identifier: "popUpArchiveTableCell")
    /// Reuse identifier `popUpSongOptionTableCell`.
    static let popUpSongOptionTableCell: Rswift.ReuseIdentifier<PopUpSongOptionTableViewCell> = Rswift.ReuseIdentifier(identifier: "popUpSongOptionTableCell")
    /// Reuse identifier `searchFilterTableCell`.
    static let searchFilterTableCell: Rswift.ReuseIdentifier<SearchFilterTableViewCell> = Rswift.ReuseIdentifier(identifier: "searchFilterTableCell")
    /// Reuse identifier `searchHistoryTableCell`.
    static let searchHistoryTableCell: Rswift.ReuseIdentifier<SearchHistoryTableViewCell> = Rswift.ReuseIdentifier(identifier: "searchHistoryTableCell")
    /// Reuse identifier `settingEtcTableCell`.
    static let settingEtcTableCell: Rswift.ReuseIdentifier<SettingEtcTableViewCell> = Rswift.ReuseIdentifier(identifier: "settingEtcTableCell")
    /// Reuse identifier `updatedSongTableViewCell`.
    static let updatedSongTableViewCell: Rswift.ReuseIdentifier<UpdatedSongTableViewCell> = Rswift.ReuseIdentifier(identifier: "updatedSongTableViewCell")

    fileprivate init() {}
  }

  /// This `R.string` struct is generated, and contains static references to 3 localization tables.
  struct string {
    /// This `R.string.infoPlist` struct is generated, and contains static references to 1 localization keys.
    struct infoPlist {
      /// en translation: NoGaDa
      ///
      /// Locales: ko, en
      static let cfBundleDisplayName = Rswift.StringResource(key: "CFBundleDisplayName", tableName: "InfoPlist", bundle: R.hostingBundle, locales: ["ko", "en"], comment: nil)

      /// en translation: NoGaDa
      ///
      /// Locales: ko, en
      static func cfBundleDisplayName(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("CFBundleDisplayName", tableName: "InfoPlist", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "InfoPlist", preferredLanguages: preferredLanguages) else {
          return "CFBundleDisplayName"
        }

        return NSLocalizedString("CFBundleDisplayName", tableName: "InfoPlist", bundle: bundle, comment: "")
      }

      fileprivate init() {}
    }

    /// This `R.string.launchScreen` struct is generated, and contains static references to 0 localization keys.
    struct launchScreen {
      fileprivate init() {}
    }

    /// This `R.string.main` struct is generated, and contains static references to 32 localization keys.
    struct main {
      /// ko translation: +   
      ///
      /// Locales: ko
      static let bTvE6Q0qNormalTitle = Rswift.StringResource(key: "bTv-E6-Q0q.normalTitle", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation: +   
      ///
      /// Locales: ko
      static let cbkYG6ktNormalTitle = Rswift.StringResource(key: "Cbk-yG-6kt.normalTitle", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation: Contact us
      ///
      /// Locales: ko
      static let p6KwGijText = Rswift.StringResource(key: "6P6-Kw-gij.text", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation: Copyright  LeeSeunggi All Right Reserved
      ///
      /// Locales: ko
      static let suC8FFRQText = Rswift.StringResource(key: "suC-8F-fRQ.text", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation: Credit
      ///
      /// Locales: ko
      static let j4OZsK0KText = Rswift.StringResource(key: "J4O-zs-k0K.text", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation: Developer : Lee Seunggi Ui/Ux Design: Lee Seunggi Contact : avocado34.131@gmail.com   Api Contributor : Yun KwangSeon Contact : middleyks@hanmail.net
      ///
      /// Locales: ko
      static let gjpOiP6XText = Rswift.StringResource(key: "gjp-Oi-p6X.text", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation: Main
      ///
      /// Locales: ko
      static let dBfGfIm0Title = Rswift.StringResource(key: "dBf-gf-Im0.title", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation: Setting
      ///
      /// Locales: ko
      static let m4g7JYGoText = Rswift.StringResource(key: "M4g-7J-YGo.text", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation: Used resources
      ///
      /// Locales: ko
      static let hgyDLW7SText = Rswift.StringResource(key: "hgy-DL-w7S.text", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation: tj
      ///
      /// Locales: ko
      static let hWmDXMxjSegmentTitles0 = Rswift.StringResource(key: "HWm-DX-mxj.segmentTitles[0]", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation:   .
      ///
      /// Locales: ko
      static let nd85PDIHText = Rswift.StringResource(key: "nd8-5P-dIH.text", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation: 
      ///
      /// Locales: ko
      static let hkWSj9w7Text = Rswift.StringResource(key: "hkW-sj-9w7.text", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation: 
      ///
      /// Locales: ko
      static let hWmDXMxjSegmentTitles1 = Rswift.StringResource(key: "HWm-DX-mxj.segmentTitles[1]", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation: 
      ///
      /// Locales: ko
      static let sVoNP6mwText = Rswift.StringResource(key: "SVo-nP-6mw.text", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation:    version 1.0.0
      ///
      /// Locales: ko
      static let skdZX9KmText = Rswift.StringResource(key: "skd-ZX-9Km.text", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation:  
      ///
      /// Locales: ko
      static let cQ5PrB1KText = Rswift.StringResource(key: "cQ5-Pr-b1K.text", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation:  
      ///
      /// Locales: ko
      static let lvi2LP6aTitle = Rswift.StringResource(key: "lvi-2L-p6a.title", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation:    !
      ///
      /// Locales: ko
      static let dluJu7ziText = Rswift.StringResource(key: "DLU-ju-7zi.text", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation:     
      ///
      /// Locales: ko
      static let vpGSOJ57Text = Rswift.StringResource(key: "VpG-sO-j57.text", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation: 
      ///
      /// Locales: ko
      static let asGYnM5wText = Rswift.StringResource(key: "asG-Yn-m5w.text", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation: 
      ///
      /// Locales: ko
      static let uos9kADVText = Rswift.StringResource(key: "UOS-9k-ADV.text", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation: 
      ///
      /// Locales: ko
      static let yscM8Y7uText = Rswift.StringResource(key: "Ysc-M8-Y7u.text", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation:  
      ///
      /// Locales: ko
      static let c4hCQ6N2Text = Rswift.StringResource(key: "C4h-cQ-6N2.text", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation:  .
      ///
      /// Locales: ko
      static let cxZCq9QeText = Rswift.StringResource(key: "CxZ-Cq-9Qe.text", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation: 
      ///
      /// Locales: ko
      static let kXrBcZdoNormalTitle = Rswift.StringResource(key: "KXr-bc-Zdo.normalTitle", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation:    
      ///
      /// Locales: ko
      static let i1LKc4uIPlaceholder = Rswift.StringResource(key: "I1L-Kc-4uI.placeholder", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation:    
      ///
      /// Locales: ko
      static let jqQh3mwText = Rswift.StringResource(key: "4Jq-qh-3mw.text", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation:  --
      ///
      /// Locales: ko
      static let i8fKbMSmText = Rswift.StringResource(key: "I8f-kb-mSm.text", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation:  
      ///
      /// Locales: ko
      static let w4J5IR6Placeholder = Rswift.StringResource(key: "7w4-j5-IR6.placeholder", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation: 
      ///
      /// Locales: ko
      static let fSoBcQ9vNormalTitle = Rswift.StringResource(key: "fSo-Bc-Q9v.normalTitle", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation: 
      ///
      /// Locales: ko
      static let cpuJ9UYfText = Rswift.StringResource(key: "Cpu-J9-uYf.text", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)
      /// ko translation: 
      ///
      /// Locales: ko
      static let zbAAjVX6Text = Rswift.StringResource(key: "zbA-aj-vX6.text", tableName: "Main", bundle: R.hostingBundle, locales: ["ko"], comment: nil)

      /// ko translation: +   
      ///
      /// Locales: ko
      static func bTvE6Q0qNormalTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("bTv-E6-Q0q.normalTitle", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "bTv-E6-Q0q.normalTitle"
        }

        return NSLocalizedString("bTv-E6-Q0q.normalTitle", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation: +   
      ///
      /// Locales: ko
      static func cbkYG6ktNormalTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Cbk-yG-6kt.normalTitle", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "Cbk-yG-6kt.normalTitle"
        }

        return NSLocalizedString("Cbk-yG-6kt.normalTitle", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation: Contact us
      ///
      /// Locales: ko
      static func p6KwGijText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("6P6-Kw-gij.text", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "6P6-Kw-gij.text"
        }

        return NSLocalizedString("6P6-Kw-gij.text", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation: Copyright  LeeSeunggi All Right Reserved
      ///
      /// Locales: ko
      static func suC8FFRQText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("suC-8F-fRQ.text", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "suC-8F-fRQ.text"
        }

        return NSLocalizedString("suC-8F-fRQ.text", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation: Credit
      ///
      /// Locales: ko
      static func j4OZsK0KText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("J4O-zs-k0K.text", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "J4O-zs-k0K.text"
        }

        return NSLocalizedString("J4O-zs-k0K.text", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation: Developer : Lee Seunggi Ui/Ux Design: Lee Seunggi Contact : avocado34.131@gmail.com   Api Contributor : Yun KwangSeon Contact : middleyks@hanmail.net
      ///
      /// Locales: ko
      static func gjpOiP6XText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("gjp-Oi-p6X.text", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "gjp-Oi-p6X.text"
        }

        return NSLocalizedString("gjp-Oi-p6X.text", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation: Main
      ///
      /// Locales: ko
      static func dBfGfIm0Title(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dBf-gf-Im0.title", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "dBf-gf-Im0.title"
        }

        return NSLocalizedString("dBf-gf-Im0.title", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation: Setting
      ///
      /// Locales: ko
      static func m4g7JYGoText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("M4g-7J-YGo.text", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "M4g-7J-YGo.text"
        }

        return NSLocalizedString("M4g-7J-YGo.text", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation: Used resources
      ///
      /// Locales: ko
      static func hgyDLW7SText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("hgy-DL-w7S.text", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "hgy-DL-w7S.text"
        }

        return NSLocalizedString("hgy-DL-w7S.text", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation: tj
      ///
      /// Locales: ko
      static func hWmDXMxjSegmentTitles0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("HWm-DX-mxj.segmentTitles[0]", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "HWm-DX-mxj.segmentTitles[0]"
        }

        return NSLocalizedString("HWm-DX-mxj.segmentTitles[0]", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation:   .
      ///
      /// Locales: ko
      static func nd85PDIHText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("nd8-5P-dIH.text", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "nd8-5P-dIH.text"
        }

        return NSLocalizedString("nd8-5P-dIH.text", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation: 
      ///
      /// Locales: ko
      static func hkWSj9w7Text(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("hkW-sj-9w7.text", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "hkW-sj-9w7.text"
        }

        return NSLocalizedString("hkW-sj-9w7.text", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation: 
      ///
      /// Locales: ko
      static func hWmDXMxjSegmentTitles1(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("HWm-DX-mxj.segmentTitles[1]", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "HWm-DX-mxj.segmentTitles[1]"
        }

        return NSLocalizedString("HWm-DX-mxj.segmentTitles[1]", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation: 
      ///
      /// Locales: ko
      static func sVoNP6mwText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("SVo-nP-6mw.text", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "SVo-nP-6mw.text"
        }

        return NSLocalizedString("SVo-nP-6mw.text", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation:    version 1.0.0
      ///
      /// Locales: ko
      static func skdZX9KmText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("skd-ZX-9Km.text", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "skd-ZX-9Km.text"
        }

        return NSLocalizedString("skd-ZX-9Km.text", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation:  
      ///
      /// Locales: ko
      static func cQ5PrB1KText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("cQ5-Pr-b1K.text", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "cQ5-Pr-b1K.text"
        }

        return NSLocalizedString("cQ5-Pr-b1K.text", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation:  
      ///
      /// Locales: ko
      static func lvi2LP6aTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("lvi-2L-p6a.title", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "lvi-2L-p6a.title"
        }

        return NSLocalizedString("lvi-2L-p6a.title", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation:    !
      ///
      /// Locales: ko
      static func dluJu7ziText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("DLU-ju-7zi.text", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "DLU-ju-7zi.text"
        }

        return NSLocalizedString("DLU-ju-7zi.text", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation:     
      ///
      /// Locales: ko
      static func vpGSOJ57Text(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("VpG-sO-j57.text", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "VpG-sO-j57.text"
        }

        return NSLocalizedString("VpG-sO-j57.text", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation: 
      ///
      /// Locales: ko
      static func asGYnM5wText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("asG-Yn-m5w.text", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "asG-Yn-m5w.text"
        }

        return NSLocalizedString("asG-Yn-m5w.text", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation: 
      ///
      /// Locales: ko
      static func uos9kADVText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("UOS-9k-ADV.text", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "UOS-9k-ADV.text"
        }

        return NSLocalizedString("UOS-9k-ADV.text", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation: 
      ///
      /// Locales: ko
      static func yscM8Y7uText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Ysc-M8-Y7u.text", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "Ysc-M8-Y7u.text"
        }

        return NSLocalizedString("Ysc-M8-Y7u.text", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation:  
      ///
      /// Locales: ko
      static func c4hCQ6N2Text(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("C4h-cQ-6N2.text", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "C4h-cQ-6N2.text"
        }

        return NSLocalizedString("C4h-cQ-6N2.text", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation:  .
      ///
      /// Locales: ko
      static func cxZCq9QeText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("CxZ-Cq-9Qe.text", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "CxZ-Cq-9Qe.text"
        }

        return NSLocalizedString("CxZ-Cq-9Qe.text", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation: 
      ///
      /// Locales: ko
      static func kXrBcZdoNormalTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("KXr-bc-Zdo.normalTitle", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "KXr-bc-Zdo.normalTitle"
        }

        return NSLocalizedString("KXr-bc-Zdo.normalTitle", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation:    
      ///
      /// Locales: ko
      static func i1LKc4uIPlaceholder(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("I1L-Kc-4uI.placeholder", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "I1L-Kc-4uI.placeholder"
        }

        return NSLocalizedString("I1L-Kc-4uI.placeholder", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation:    
      ///
      /// Locales: ko
      static func jqQh3mwText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("4Jq-qh-3mw.text", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "4Jq-qh-3mw.text"
        }

        return NSLocalizedString("4Jq-qh-3mw.text", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation:  --
      ///
      /// Locales: ko
      static func i8fKbMSmText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("I8f-kb-mSm.text", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "I8f-kb-mSm.text"
        }

        return NSLocalizedString("I8f-kb-mSm.text", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation:  
      ///
      /// Locales: ko
      static func w4J5IR6Placeholder(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("7w4-j5-IR6.placeholder", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "7w4-j5-IR6.placeholder"
        }

        return NSLocalizedString("7w4-j5-IR6.placeholder", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation: 
      ///
      /// Locales: ko
      static func fSoBcQ9vNormalTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("fSo-Bc-Q9v.normalTitle", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "fSo-Bc-Q9v.normalTitle"
        }

        return NSLocalizedString("fSo-Bc-Q9v.normalTitle", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation: 
      ///
      /// Locales: ko
      static func cpuJ9UYfText(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Cpu-J9-uYf.text", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "Cpu-J9-uYf.text"
        }

        return NSLocalizedString("Cpu-J9-uYf.text", tableName: "Main", bundle: bundle, comment: "")
      }

      /// ko translation: 
      ///
      /// Locales: ko
      static func zbAAjVX6Text(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("zbA-aj-vX6.text", tableName: "Main", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Main", preferredLanguages: preferredLanguages) else {
          return "zbA-aj-vX6.text"
        }

        return NSLocalizedString("zbA-aj-vX6.text", tableName: "Main", bundle: bundle, comment: "")
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  fileprivate struct intern: Rswift.Validatable {
    fileprivate static func validate() throws {
      try _R.validate()
    }

    fileprivate init() {}
  }

  fileprivate class Class {}

  fileprivate init() {}
}

struct _R: Rswift.Validatable {
  static func validate() throws {
    #if os(iOS) || os(tvOS)
    try nib.validate()
    #endif
    #if os(iOS) || os(tvOS)
    try storyboard.validate()
    #endif
  }

  #if os(iOS) || os(tvOS)
  struct nib: Rswift.Validatable {
    static func validate() throws {
      try _SearchHistoryTableViewCell.validate()
      try _SettingEtcTableViewCell.validate()
      try _SongTableViewCell.validate()
      try _UpdatedSongTableViewCell.validate()
    }

    struct _FolderTableViewCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType {
      typealias ReusableType = FolderTableViewCell

      let bundle = R.hostingBundle
      let identifier = "folderTableViewCell"
      let name = "FolderTableViewCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> FolderTableViewCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? FolderTableViewCell
      }

      fileprivate init() {}
    }

    struct _IconResourceCollectionViewCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType {
      typealias ReusableType = IconResourceCollectionViewCell

      let bundle = R.hostingBundle
      let identifier = "iconResourceCollectionCell"
      let name = "IconResourceCollectionViewCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> IconResourceCollectionViewCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? IconResourceCollectionViewCell
      }

      fileprivate init() {}
    }

    struct _KaraokeBrandPickerTableViewCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType {
      typealias ReusableType = KaraokeBrandPickerTableViewCell

      let bundle = R.hostingBundle
      let identifier = "karaokeBrandTableCell"
      let name = "KaraokeBrandPickerTableViewCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> KaraokeBrandPickerTableViewCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? KaraokeBrandPickerTableViewCell
      }

      fileprivate init() {}
    }

    struct _PopUpArchiveFolderTableViewCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType {
      typealias ReusableType = PopUpArchiveFolderTableViewCell

      let bundle = R.hostingBundle
      let identifier = "popUpArchiveTableCell"
      let name = "PopUpArchiveFolderTableViewCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> PopUpArchiveFolderTableViewCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? PopUpArchiveFolderTableViewCell
      }

      fileprivate init() {}
    }

    struct _PopUpSongOptionTableViewCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType {
      typealias ReusableType = PopUpSongOptionTableViewCell

      let bundle = R.hostingBundle
      let identifier = "popUpSongOptionTableCell"
      let name = "PopUpSongOptionTableViewCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> PopUpSongOptionTableViewCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? PopUpSongOptionTableViewCell
      }

      fileprivate init() {}
    }

    struct _SearchFilterTableViewCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType {
      typealias ReusableType = SearchFilterTableViewCell

      let bundle = R.hostingBundle
      let identifier = "searchFilterTableCell"
      let name = "SearchFilterTableViewCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> SearchFilterTableViewCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? SearchFilterTableViewCell
      }

      fileprivate init() {}
    }

    struct _SearchHistoryTableViewCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType, Rswift.Validatable {
      typealias ReusableType = SearchHistoryTableViewCell

      let bundle = R.hostingBundle
      let identifier = "searchHistoryTableCell"
      let name = "SearchHistoryTableViewCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> SearchHistoryTableViewCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? SearchHistoryTableViewCell
      }

      static func validate() throws {
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "magnifyingglass") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'magnifyingglass' is used in nib 'SearchHistoryTableViewCell', but couldn't be loaded.") } }
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "xmark") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'xmark' is used in nib 'SearchHistoryTableViewCell', but couldn't be loaded.") } }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "BackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'BackgroundColor' is used in nib 'SearchHistoryTableViewCell', but couldn't be loaded.") }
          if UIKit.UIColor(named: "SubTextColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'SubTextColor' is used in nib 'SearchHistoryTableViewCell', but couldn't be loaded.") }
          if UIKit.UIColor(named: "TextColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'TextColor' is used in nib 'SearchHistoryTableViewCell', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _SettingEtcTableViewCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType, Rswift.Validatable {
      typealias ReusableType = SettingEtcTableViewCell

      let bundle = R.hostingBundle
      let identifier = "settingEtcTableCell"
      let name = "SettingEtcTableViewCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> SettingEtcTableViewCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? SettingEtcTableViewCell
      }

      static func validate() throws {
        if UIKit.UIImage(named: "information.fill", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'information.fill' is used in nib 'SettingEtcTableViewCell', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "SettingGroupBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'SettingGroupBackgroundColor' is used in nib 'SettingEtcTableViewCell', but couldn't be loaded.") }
          if UIKit.UIColor(named: "SettingIconBoxBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'SettingIconBoxBackgroundColor' is used in nib 'SettingEtcTableViewCell', but couldn't be loaded.") }
          if UIKit.UIColor(named: "SettingIconBoxForegroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'SettingIconBoxForegroundColor' is used in nib 'SettingEtcTableViewCell', but couldn't be loaded.") }
          if UIKit.UIColor(named: "TextColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'TextColor' is used in nib 'SettingEtcTableViewCell', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _SongTableViewCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType, Rswift.Validatable {
      typealias ReusableType = SongTableViewCell

      let bundle = R.hostingBundle
      let identifier = "SearchResultTableViewCell"
      let name = "SongTableViewCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> SongTableViewCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? SongTableViewCell
      }

      static func validate() throws {
        if UIKit.UIImage(named: "music-note", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'music-note' is used in nib 'SongTableViewCell', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "BackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'BackgroundColor' is used in nib 'SongTableViewCell', but couldn't be loaded.") }
          if UIKit.UIColor(named: "SongThumbnailBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'SongThumbnailBackgroundColor' is used in nib 'SongTableViewCell', but couldn't be loaded.") }
          if UIKit.UIColor(named: "SongThumbnailForegroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'SongThumbnailForegroundColor' is used in nib 'SongTableViewCell', but couldn't be loaded.") }
          if UIKit.UIColor(named: "SubTextColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'SubTextColor' is used in nib 'SongTableViewCell', but couldn't be loaded.") }
          if UIKit.UIColor(named: "TextColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'TextColor' is used in nib 'SongTableViewCell', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _UpdatedSongTableViewCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType, Rswift.Validatable {
      typealias ReusableType = UpdatedSongTableViewCell

      let bundle = R.hostingBundle
      let identifier = "updatedSongTableViewCell"
      let name = "UpdatedSongTableViewCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UpdatedSongTableViewCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UpdatedSongTableViewCell
      }

      static func validate() throws {
        if UIKit.UIImage(named: "music-note", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'music-note' is used in nib 'UpdatedSongTableViewCell', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "BackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'BackgroundColor' is used in nib 'UpdatedSongTableViewCell', but couldn't be loaded.") }
          if UIKit.UIColor(named: "SongThumbnailBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'SongThumbnailBackgroundColor' is used in nib 'UpdatedSongTableViewCell', but couldn't be loaded.") }
          if UIKit.UIColor(named: "SongThumbnailForegroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'SongThumbnailForegroundColor' is used in nib 'UpdatedSongTableViewCell', but couldn't be loaded.") }
          if UIKit.UIColor(named: "SubTextColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'SubTextColor' is used in nib 'UpdatedSongTableViewCell', but couldn't be loaded.") }
          if UIKit.UIColor(named: "TextColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'TextColor' is used in nib 'UpdatedSongTableViewCell', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }
  #endif

  #if os(iOS) || os(tvOS)
  struct storyboard: Rswift.Validatable {
    static func validate() throws {
      #if os(iOS) || os(tvOS)
      try archive.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try folder.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try launchScreen.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try main.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try search.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try setting.validate()
      #endif
    }

    #if os(iOS) || os(tvOS)
    struct archive: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = ArchiveFolderViewController

      let addSongStoryboard = StoryboardViewControllerResource<AddSongViewController>(identifier: "AddSongStoryboard")
      let archiveFolderStoryboard = StoryboardViewControllerResource<ArchiveFolderViewController>(identifier: "ArchiveFolderStoryboard")
      let archiveSongStoryboard = StoryboardViewControllerResource<ArchiveSongViewController>(identifier: "ArchiveSongStoryboard")
      let bundle = R.hostingBundle
      let karaokeBrandPickerStoryboard = StoryboardViewControllerResource<KaraokeBrandPickerViewController>(identifier: "karaokeBrandPickerStoryboard")
      let name = "Archive"
      let popUpSongOptionStoryboard = StoryboardViewControllerResource<PopUpSongOptionViewController>(identifier: "popUpSongOptionStoryboard")

      func addSongStoryboard(_: Void = ()) -> AddSongViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: addSongStoryboard)
      }

      func archiveFolderStoryboard(_: Void = ()) -> ArchiveFolderViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: archiveFolderStoryboard)
      }

      func archiveSongStoryboard(_: Void = ()) -> ArchiveSongViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: archiveSongStoryboard)
      }

      func karaokeBrandPickerStoryboard(_: Void = ()) -> KaraokeBrandPickerViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: karaokeBrandPickerStoryboard)
      }

      func popUpSongOptionStoryboard(_: Void = ()) -> PopUpSongOptionViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: popUpSongOptionStoryboard)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "music-note", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'music-note' is used in storyboard 'Archive', but couldn't be loaded.") }
        if UIKit.UIImage(named: "plus", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'plus' is used in storyboard 'Archive', but couldn't be loaded.") }
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "xmark") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'xmark' is used in storyboard 'Archive', but couldn't be loaded.") } }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "AddFolderButtonBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AddFolderButtonBackgroundColor' is used in storyboard 'Archive', but couldn't be loaded.") }
          if UIKit.UIColor(named: "AddFolderButtonForegroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AddFolderButtonForegroundColor' is used in storyboard 'Archive', but couldn't be loaded.") }
          if UIKit.UIColor(named: "AppbarBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AppbarBackgroundColor' is used in storyboard 'Archive', but couldn't be loaded.") }
          if UIKit.UIColor(named: "AppbarExitButtonBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AppbarExitButtonBackgroundColor' is used in storyboard 'Archive', but couldn't be loaded.") }
          if UIKit.UIColor(named: "AppbarTextColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AppbarTextColor' is used in storyboard 'Archive', but couldn't be loaded.") }
          if UIKit.UIColor(named: "AppbarTextfieldBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AppbarTextfieldBackgroundColor' is used in storyboard 'Archive', but couldn't be loaded.") }
          if UIKit.UIColor(named: "AppbarTextfieldTextColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AppbarTextfieldTextColor' is used in storyboard 'Archive', but couldn't be loaded.") }
          if UIKit.UIColor(named: "BackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'BackgroundColor' is used in storyboard 'Archive', but couldn't be loaded.") }
          if UIKit.UIColor(named: "CreateFolderButtonForegroundColor1", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'CreateFolderButtonForegroundColor1' is used in storyboard 'Archive', but couldn't be loaded.") }
          if UIKit.UIColor(named: "ExitButtonForegroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'ExitButtonForegroundColor' is used in storyboard 'Archive', but couldn't be loaded.") }
          if UIKit.UIColor(named: "FloatingButtonBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'FloatingButtonBackgroundColor' is used in storyboard 'Archive', but couldn't be loaded.") }
          if UIKit.UIColor(named: "FloatingButtonForegroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'FloatingButtonForegroundColor' is used in storyboard 'Archive', but couldn't be loaded.") }
          if UIKit.UIColor(named: "NotificationViewBakcgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'NotificationViewBakcgroundColor' is used in storyboard 'Archive', but couldn't be loaded.") }
          if UIKit.UIColor(named: "PopOverBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'PopOverBackgroundColor' is used in storyboard 'Archive', but couldn't be loaded.") }
          if UIKit.UIColor(named: "SeparatorColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'SeparatorColor' is used in storyboard 'Archive', but couldn't be loaded.") }
          if UIKit.UIColor(named: "SongThumbnailBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'SongThumbnailBackgroundColor' is used in storyboard 'Archive', but couldn't be loaded.") }
          if UIKit.UIColor(named: "SongThumbnailForegroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'SongThumbnailForegroundColor' is used in storyboard 'Archive', but couldn't be loaded.") }
          if UIKit.UIColor(named: "SubTextColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'SubTextColor' is used in storyboard 'Archive', but couldn't be loaded.") }
          if UIKit.UIColor(named: "TextColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'TextColor' is used in storyboard 'Archive', but couldn't be loaded.") }
          if UIKit.UIColor(named: "TextFieldBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'TextFieldBackgroundColor' is used in storyboard 'Archive', but couldn't be loaded.") }
        }
        if _R.storyboard.archive().addSongStoryboard() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'addSongStoryboard' could not be loaded from storyboard 'Archive' as 'AddSongViewController'.") }
        if _R.storyboard.archive().archiveFolderStoryboard() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'archiveFolderStoryboard' could not be loaded from storyboard 'Archive' as 'ArchiveFolderViewController'.") }
        if _R.storyboard.archive().archiveSongStoryboard() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'archiveSongStoryboard' could not be loaded from storyboard 'Archive' as 'ArchiveSongViewController'.") }
        if _R.storyboard.archive().karaokeBrandPickerStoryboard() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'karaokeBrandPickerStoryboard' could not be loaded from storyboard 'Archive' as 'KaraokeBrandPickerViewController'.") }
        if _R.storyboard.archive().popUpSongOptionStoryboard() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'popUpSongOptionStoryboard' could not be loaded from storyboard 'Archive' as 'PopUpSongOptionViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct folder: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = PopUpArchiveFolderViewController

      let addFolderStoryboard = StoryboardViewControllerResource<AddFolderViewController>(identifier: "addFolderStoryboard")
      let bundle = R.hostingBundle
      let name = "Folder"
      let popUpArchiveFolderStoryboard = StoryboardViewControllerResource<PopUpArchiveFolderViewController>(identifier: "popUpArchiveFolderStoryboard")

      func addFolderStoryboard(_: Void = ()) -> AddFolderViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: addFolderStoryboard)
      }

      func popUpArchiveFolderStoryboard(_: Void = ()) -> PopUpArchiveFolderViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: popUpArchiveFolderStoryboard)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "folder-filled", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'folder-filled' is used in storyboard 'Folder', but couldn't be loaded.") }
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "xmark") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'xmark' is used in storyboard 'Folder', but couldn't be loaded.") } }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "AccentSubColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AccentSubColor' is used in storyboard 'Folder', but couldn't be loaded.") }
          if UIKit.UIColor(named: "AddFolderButtonBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AddFolderButtonBackgroundColor' is used in storyboard 'Folder', but couldn't be loaded.") }
          if UIKit.UIColor(named: "AddFolderButtonForegroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AddFolderButtonForegroundColor' is used in storyboard 'Folder', but couldn't be loaded.") }
          if UIKit.UIColor(named: "AddFolderButtonReversedBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AddFolderButtonReversedBackgroundColor' is used in storyboard 'Folder', but couldn't be loaded.") }
          if UIKit.UIColor(named: "AppbarBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AppbarBackgroundColor' is used in storyboard 'Folder', but couldn't be loaded.") }
          if UIKit.UIColor(named: "AppbarExitButtonBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AppbarExitButtonBackgroundColor' is used in storyboard 'Folder', but couldn't be loaded.") }
          if UIKit.UIColor(named: "AppbarTextColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AppbarTextColor' is used in storyboard 'Folder', but couldn't be loaded.") }
          if UIKit.UIColor(named: "BackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'BackgroundColor' is used in storyboard 'Folder', but couldn't be loaded.") }
          if UIKit.UIColor(named: "CreateFolderButtonForegroundColor1", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'CreateFolderButtonForegroundColor1' is used in storyboard 'Folder', but couldn't be loaded.") }
          if UIKit.UIColor(named: "ExitButtonForegroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'ExitButtonForegroundColor' is used in storyboard 'Folder', but couldn't be loaded.") }
          if UIKit.UIColor(named: "PopUpArchiveBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'PopUpArchiveBackgroundColor' is used in storyboard 'Folder', but couldn't be loaded.") }
          if UIKit.UIColor(named: "TextColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'TextColor' is used in storyboard 'Folder', but couldn't be loaded.") }
          if UIKit.UIColor(named: "TextFieldBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'TextFieldBackgroundColor' is used in storyboard 'Folder', but couldn't be loaded.") }
        }
        if _R.storyboard.folder().addFolderStoryboard() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'addFolderStoryboard' could not be loaded from storyboard 'Folder' as 'AddFolderViewController'.") }
        if _R.storyboard.folder().popUpArchiveFolderStoryboard() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'popUpArchiveFolderStoryboard' could not be loaded from storyboard 'Folder' as 'PopUpArchiveFolderViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct launchScreen: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UIViewController

      let bundle = R.hostingBundle
      let name = "LaunchScreen"

      static func validate() throws {
        if UIKit.UIImage(named: "SplashImage", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'SplashImage' is used in storyboard 'LaunchScreen', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "SplashBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'SplashBackgroundColor' is used in storyboard 'LaunchScreen', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct main: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = MainViewController

      let bundle = R.hostingBundle
      let mainStoryboard = StoryboardViewControllerResource<MainViewController>(identifier: "MainStoryboard")
      let name = "Main"

      func mainStoryboard(_: Void = ()) -> MainViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: mainStoryboard)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "ArchiveShortcutBackgroundImage", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ArchiveShortcutBackgroundImage' is used in storyboard 'Main', but couldn't be loaded.") }
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "magnifyingglass") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'magnifyingglass' is used in storyboard 'Main', but couldn't be loaded.") } }
        if UIKit.UIImage(named: "setting", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'setting' is used in storyboard 'Main', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "AppbarBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AppbarBackgroundColor' is used in storyboard 'Main', but couldn't be loaded.") }
          if UIKit.UIColor(named: "AppbarTextColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AppbarTextColor' is used in storyboard 'Main', but couldn't be loaded.") }
          if UIKit.UIColor(named: "AppbarTextfieldBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AppbarTextfieldBackgroundColor' is used in storyboard 'Main', but couldn't be loaded.") }
          if UIKit.UIColor(named: "AppbarTextfieldPlaceholderColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AppbarTextfieldPlaceholderColor' is used in storyboard 'Main', but couldn't be loaded.") }
          if UIKit.UIColor(named: "ArchiveShortcutBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'ArchiveShortcutBackgroundColor' is used in storyboard 'Main', but couldn't be loaded.") }
          if UIKit.UIColor(named: "ArchiveShortcutPlaceholderColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'ArchiveShortcutPlaceholderColor' is used in storyboard 'Main', but couldn't be loaded.") }
          if UIKit.UIColor(named: "BackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'BackgroundColor' is used in storyboard 'Main', but couldn't be loaded.") }
          if UIKit.UIColor(named: "LoadingIndicatorColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'LoadingIndicatorColor' is used in storyboard 'Main', but couldn't be loaded.") }
          if UIKit.UIColor(named: "TextFieldPlaceholderColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'TextFieldPlaceholderColor' is used in storyboard 'Main', but couldn't be loaded.") }
        }
        if _R.storyboard.main().mainStoryboard() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'mainStoryboard' could not be loaded from storyboard 'Main' as 'MainViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct search: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = SearchViewController

      let bundle = R.hostingBundle
      let name = "Search"
      let popOverSearchFilterStoryboard = StoryboardViewControllerResource<PopOverSearchFilterViewController>(identifier: "PopOverSearchFilterStoryboard")
      let searchHistoryStoryboard = StoryboardViewControllerResource<SearchHistoryViewController>(identifier: "SearchHistoryStoryboard")
      let searchResultStoryboard = StoryboardViewControllerResource<SearchResultViewController>(identifier: "SearchResultStoryboard")
      let searchStoryboard = StoryboardViewControllerResource<SearchViewController>(identifier: "SearchStoryboard")

      func popOverSearchFilterStoryboard(_: Void = ()) -> PopOverSearchFilterViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: popOverSearchFilterStoryboard)
      }

      func searchHistoryStoryboard(_: Void = ()) -> SearchHistoryViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: searchHistoryStoryboard)
      }

      func searchResultStoryboard(_: Void = ()) -> SearchResultViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: searchResultStoryboard)
      }

      func searchStoryboard(_: Void = ()) -> SearchViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: searchStoryboard)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "back-arrow", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'back-arrow' is used in storyboard 'Search', but couldn't be loaded.") }
        if UIKit.UIImage(named: "sort-line", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'sort-line' is used in storyboard 'Search', but couldn't be loaded.") }
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "xmark") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'xmark' is used in storyboard 'Search', but couldn't be loaded.") } }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "AddFolderButtonBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AddFolderButtonBackgroundColor' is used in storyboard 'Search', but couldn't be loaded.") }
          if UIKit.UIColor(named: "AddFolderButtonForegroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AddFolderButtonForegroundColor' is used in storyboard 'Search', but couldn't be loaded.") }
          if UIKit.UIColor(named: "AppbarBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AppbarBackgroundColor' is used in storyboard 'Search', but couldn't be loaded.") }
          if UIKit.UIColor(named: "AppbarTextColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AppbarTextColor' is used in storyboard 'Search', but couldn't be loaded.") }
          if UIKit.UIColor(named: "AppbarTextfieldBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AppbarTextfieldBackgroundColor' is used in storyboard 'Search', but couldn't be loaded.") }
          if UIKit.UIColor(named: "BackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'BackgroundColor' is used in storyboard 'Search', but couldn't be loaded.") }
          if UIKit.UIColor(named: "ClearTextfieldButtonColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'ClearTextfieldButtonColor' is used in storyboard 'Search', but couldn't be loaded.") }
          if UIKit.UIColor(named: "ExitButtonForegroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'ExitButtonForegroundColor' is used in storyboard 'Search', but couldn't be loaded.") }
          if UIKit.UIColor(named: "LoadingIndicatorColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'LoadingIndicatorColor' is used in storyboard 'Search', but couldn't be loaded.") }
          if UIKit.UIColor(named: "SegmentedControlAccentColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'SegmentedControlAccentColor' is used in storyboard 'Search', but couldn't be loaded.") }
          if UIKit.UIColor(named: "SegmentedControlBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'SegmentedControlBackgroundColor' is used in storyboard 'Search', but couldn't be loaded.") }
          if UIKit.UIColor(named: "SubTextColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'SubTextColor' is used in storyboard 'Search', but couldn't be loaded.") }
          if UIKit.UIColor(named: "TextColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'TextColor' is used in storyboard 'Search', but couldn't be loaded.") }
          if UIKit.UIColor(named: "TextFieldPlaceholderColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'TextFieldPlaceholderColor' is used in storyboard 'Search', but couldn't be loaded.") }
        }
        if _R.storyboard.search().popOverSearchFilterStoryboard() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'popOverSearchFilterStoryboard' could not be loaded from storyboard 'Search' as 'PopOverSearchFilterViewController'.") }
        if _R.storyboard.search().searchHistoryStoryboard() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'searchHistoryStoryboard' could not be loaded from storyboard 'Search' as 'SearchHistoryViewController'.") }
        if _R.storyboard.search().searchResultStoryboard() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'searchResultStoryboard' could not be loaded from storyboard 'Search' as 'SearchResultViewController'.") }
        if _R.storyboard.search().searchStoryboard() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'searchStoryboard' could not be loaded from storyboard 'Search' as 'SearchViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct setting: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = SettingViewController

      let bundle = R.hostingBundle
      let creditStoryboard = StoryboardViewControllerResource<CreditViewController>(identifier: "creditStoryboard")
      let name = "Setting"
      let settingStoryboard = StoryboardViewControllerResource<SettingViewController>(identifier: "settingStoryboard")

      func creditStoryboard(_: Void = ()) -> CreditViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: creditStoryboard)
      }

      func settingStoryboard(_: Void = ()) -> SettingViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: settingStoryboard)
      }

      static func validate() throws {
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "phone.fill") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'phone.fill' is used in storyboard 'Setting', but couldn't be loaded.") } }
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "xmark") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'xmark' is used in storyboard 'Setting', but couldn't be loaded.") } }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "AccentColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'AccentColor' is used in storyboard 'Setting', but couldn't be loaded.") }
          if UIKit.UIColor(named: "BackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'BackgroundColor' is used in storyboard 'Setting', but couldn't be loaded.") }
          if UIKit.UIColor(named: "SettingGroupBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'SettingGroupBackgroundColor' is used in storyboard 'Setting', but couldn't be loaded.") }
          if UIKit.UIColor(named: "SettingGroupHeaderTextColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'SettingGroupHeaderTextColor' is used in storyboard 'Setting', but couldn't be loaded.") }
          if UIKit.UIColor(named: "SettingIconBoxBackgroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'SettingIconBoxBackgroundColor' is used in storyboard 'Setting', but couldn't be loaded.") }
          if UIKit.UIColor(named: "SettingIconBoxForegroundColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'SettingIconBoxForegroundColor' is used in storyboard 'Setting', but couldn't be loaded.") }
          if UIKit.UIColor(named: "TextColor", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'TextColor' is used in storyboard 'Setting', but couldn't be loaded.") }
        }
        if _R.storyboard.setting().creditStoryboard() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'creditStoryboard' could not be loaded from storyboard 'Setting' as 'CreditViewController'.") }
        if _R.storyboard.setting().settingStoryboard() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'settingStoryboard' could not be loaded from storyboard 'Setting' as 'SettingViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    fileprivate init() {}
  }
  #endif

  fileprivate init() {}
}
